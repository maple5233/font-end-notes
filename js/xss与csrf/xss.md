# XSS攻击
## XSS攻击是什么
+ XSS是跨站脚本攻击的缩写，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。  
+ 通常是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。  
+ 这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。  
+ 攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。

## XSS攻击基本原理——代码注入
在web的世界里有各种各样的语言，于是乎对于语句的解析大家各不相同，有一些语句在一种语言里是合法的，但是在另外一种语言里是非法的。这种二义性使得黑客可以用代码注入的方式进行攻击——将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。只要破坏跨层协议的数据/指令的构造，我们就能攻击。
历史悠久的`SQL注入`和`XSS注入`都是这种攻击方式的典范。现如今，随着参数化查询的普及，我们已经离`SQL注入`很远了。但是，历史同样悠久的`XSS`却没有远离我们。  
`XSS`的基本实现思路很简单——比如`持久型XSS`通过一些正常的站内交互途径，例如发布评论，提交含有`JavaScript`的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本，从而被攻击。

## 攻击分类举例
### 反射型XSS 
反射性XSS，也就是被动的非持久性XSS。诱骗用户点击URL带攻击代码的链接，服务器解析后响应，在返回的响应内容中隐藏和嵌入攻击者的XSS代码，被浏览器执行，从而攻击用户。  
URL可能被用户怀疑，但是可以通过短网址服务将之缩短，从而隐藏自己。

### 持久型XSS 
也叫存储型XSS——主动提交恶意数据到服务器，攻击者在数据中嵌入代码，这样当其他用户请求后，服务器从数据库中查询数据并发给用户，用户浏览此类页面时就可能受到攻击。可以描述为:恶意用户的HTML或JS输入服务器->进入数据库->服务器响应时查询数据库->用户浏览器。

### DOM-based XSS 
基于DOM的XSS，通过对具体DOM代码进行分析，根据实际情况**构造dom节点**进行XSS跨站脚本攻击。 

注：domxss取决于输出位置，并不取决于输出环境，因此domxss既有可能是反射型的，也有可能是存储型的。dom-based与非dom-based，反射和存储是两个不同的分类标准。


## 防范
记住一句至理名言——“所有用户输入都是不可信的。”（注意:  攻击代码不一定在<script></script>中）

### 使用XSS Filter
+ 输入过滤，对用户提交的数据进行有效性验证，仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。
+ 输出转义，当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符，为了确保输出内容的完整性和正确性，输出HTML属性时可以使用HTML转义编码（HTMLEncode）进行处理，输出到<script\>中，可以进行JS编码。

### 使用 HttpOnly Cookie
将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上`cookie`字段，但是在`js`脚本中却不能访问这个cookie，这样就避免了XSS攻击利用`JavaScript`的`document.cookie`获取`cookie`。

### 困难和幸运
真正麻烦的是，在一些场合我们要允许用户输入HTML，又要过滤其中的脚本。这就要求我们对代码小心地进行转义。否则，我们可能既获取不了用户的正确输入，又被XSS攻击。  
幸好，由于XSS臭名昭著历史悠久又极其危险，现代web开发框架如`vue.js`、`react.js`等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。  
同时，许多基于`MVVM`框架的`SPA`（单页应用）不需要刷新URL来控制view，这样大大防止了XSS隐患。另外，我们还可以用一些防火墙来阻止XSS的运行。